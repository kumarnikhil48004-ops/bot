# telegram_bot.py
import asyncio
import json
import logging
from typing import Any

import requests
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, ContextTypes, filters

# ---------------- CONFIG ----------------
TELEGRAM_TOKEN = "8213749728:AAF8LJJ11pVwpVCjTcbSU5UIZ2-3BF0C08s"   # â† Replace with your bot token
BASE_URL = "https://ravan-lookup.vercel.app/api?key=Ravan&type=mobile&term="
HEADER_TEXT = "ðŸ’¾HiTeckGroop.in"
DEFAULT_KEY = "Demo"   # allowed keys: "Demo", "Paid"
MAX_TG_MSG_CHARS = 4000  # keep smaller than Telegram limit (4096)

# ---------------- Logging ----------------
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)


# ---------------- Helpers ----------------
def clean_data(obj: Any) -> Any:
    """
    Remove unwanted keys recursively and return cleaned object.
    """
    if isinstance(obj, dict):
        obj.pop("developer", None)
        obj.pop("credit", None)
        for k in list(obj.keys()):
            obj[k] = clean_data(obj[k])
        return obj
    elif isinstance(obj, list):
        return [clean_data(i) for i in obj]
    else:
        return obj


def format_response(header: str, data: Any) -> str:
    """
    Create a reasonably short string to send as Telegram message.
    """
    if isinstance(data, (dict, list)):
        pretty = json.dumps(data, indent=2, ensure_ascii=False)
    else:
        pretty = str(data)

    body = f"{header}\nTotal Records: { (len(data) if isinstance(data, list) else 1) if data else 0 }\n\n{pretty}"
    # Truncate if too long
    if len(body) > MAX_TG_MSG_CHARS:
        body = body[: MAX_TG_MSG_CHARS - 50] + "\n\n...[truncated]"
    return f"```\n{body}\n```"


async def fetch_from_api(mobile: str, key: str = DEFAULT_KEY) -> Any:
    """
    Performs blocking requests.get inside a thread to avoid blocking event loop.
    Returns parsed JSON/dict or string wrapped in dict.
    """
    url = f"{BASE_URL}{mobile}"
    try:
        # run blocking requests in thread
        resp = await asyncio.to_thread(requests.get, url, {"timeout": 10} if False else None)
        # Note: above passes no params to requests.get except url because BASE_URL already contains query.
        # If you want to pass timeout:
        # resp = await asyncio.to_thread(requests.get, url, timeout=10)

        # ensure status
        resp.raise_for_status()
        text = resp.text.strip()
        if not text:
            return {"header": HEADER_TEXT, "data": [], "total": 0}

        try:
            parsed = json.loads(text)
        except Exception:
            parsed = {"raw": text}

        cleaned = clean_data(parsed)
        total = len(cleaned) if isinstance(cleaned, list) else 1
        return {"header": HEADER_TEXT, "data": cleaned, "total": total}
    except Exception as e:
        logger.exception("Error fetching API")
        return {"header": HEADER_TEXT, "data": [], "total": 0, "error": str(e)}


# ---------------- Handlers ----------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Hi! Send me a mobile number (or use /lookup <mobile> [key]).\nExample: /lookup 9876543210 Demo"
    )


async def lookup_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    args = context.args
    if not args:
        await update.message.reply_text("Usage: /lookup <mobile> [key]\nExample: /lookup 9876543210 Demo")
        return

    mobile = args[0].strip()
    key = args[1].strip() if len(args) > 1 else DEFAULT_KEY
    if key not in ["Demo", "Paid"]:
        await update.message.reply_text("Invalid key. Allowed keys: Demo, Paid")
        return

    # Inform user we're fetching
    msg = await update.message.reply_text("Fetching data...")

    result = await fetch_from_api(mobile, key)
    formatted = format_response(result.get("header", HEADER_TEXT), result.get("data"))
    try:
        await msg.edit_text(formatted, parse_mode="MarkdownV2")
    except Exception:
        # fallback (some characters can break MarkdownV2); send plain
        await msg.edit_text(json.dumps(result, indent=2, ensure_ascii=False))


async def text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Treat any text message as mobile number lookup (for convenience).
    """
    mobile = update.message.text.strip()
    # rudimentary validation (only digits, 7-15 length)
    if not mobile.isdigit() or not (7 <= len(mobile) <= 15):
        await update.message.reply_text("Send a valid mobile number (digits only). Or use /lookup.")
        return

    tmp = await update.message.reply_text("Looking up...")
    result = await fetch_from_api(mobile, DEFAULT_KEY)
    formatted = format_response(result.get("header", HEADER_TEXT), result.get("data"))
    try:
        await tmp.edit_text(formatted, parse_mode="MarkdownV2")
    except Exception:
        await tmp.edit_text(json.dumps(result, indent=2, ensure_ascii=False))


# ---------------- Main ----------------
def main():
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("lookup", lookup_command))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_message))

    print("Bot started (polling). Press Ctrl-C to stop.")
    app.run_polling()


if __name__ == "__main__":
    main()
